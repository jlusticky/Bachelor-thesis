%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{Protothreads}\label{sec:contiki-protothreads}
Protothreads provide a way for C functions to run quasi-parallel,
that is, a C function work in a way similar to a thread~\cite{paper-protothreads}.
In Contiki, Protothreads allow to wait for incoming events without blocking the whole system.
While waiting for an event to occur, another function could be run.
The core of this solution is the C {\it switch} statement used in conjunction with a variable (called local continuation)
containing the position, where the function was blocked~\cite{paper-protothreads}.
The function continues from this point next time.

The advantage of Protothreads over ordinary threads is that a Protothread does not require a separate stack.
The overhead of allocating multiple stacks can consume large amounts of
available memory in memory constrained systems~\cite{paper-protothreads}.
In contrast, each Protothread requires only a few bytes for storing the state of execution.

A Protothread is driven by repeated calls of the function in which the Protothread is running. %LYDIA
Each time the function is called, the Protothread will run until it blocks or exits.
Protothreads are implemented using the local continuations. The local continuation represents the current state
of execution at a particular position in the program, but does not provide any call history or local variables~\cite{contiki-docs}.

The Protothreads API consists of four basic operations: initialisation {\it{PT\_INIT()}}, execution {\it{PT\_BEGIN()}},
conditional blocking {\it{PT\_WAIT\_UNTIL()}} and exit {\it{PT\_END()}}~\cite{paper-protothreads}.
However, the experience with rewriting event-driven state machines to Protothreads revealed %!LYDIA
the importance of an unconditional blocking wait {\it{PT\_YIELD()}},
which temporarily blocks the Protothread until the next time the Protothread is invoked~\cite{thesis-programming}.
After invoked, the Protothread continues executing the code following the {\it{PT\_YIELD()}} statement. %!LYDIA invocation
To understand the implementation of Protothreads and how they actually work,
please refer to appendix~\ref{app:protothreads}, where an example of use is shown.

Since Protothreads are implemented using standard C, a library providing Protothreads can be used everywhere,
where the C toolchain is available.
But there are some constraints to consider.
Because Protothreads are stackless, a Protothread can run only within a single C function. %!LYDIA
There is also no way of storing automatic local variables~\cite{contiki-docs}. %LYDIA of
And since Protothreads are implemented using the C {\it switch} statement, and these can %!LYDIA
not be nested, the code that uses Protothreads cannot use the {\it switch} statements itself.
A workaround for storing local variables is to prepend them with the {\it static} keyword,
which makes them being put into the data segment %!LYDIA
by the compiler and thus remembering their values between the function calls~\cite{paper-protothreads}.
