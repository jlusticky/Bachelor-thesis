%=========================================================================
% (c) 2011, 2012 Josef Lusticky <xlusti00@stud.fit.vutbr.cz>

\section{Protothreads}\label{sec:contiki-protothreads}
Protothreads provide a way to run C functions quasi-parallely,
that is, a C functions work in a way similar to thread~\cite{paper-protothreads}.
In Contiki Protothreads allow process to wait for incoming events and
while waiting for an event to occur, another function could be run.
The core of this solution is C {\it switch} statement used in conjunction with variable (called local continuation)
containing position, where the function was interrupted~\cite{paper-protothreads}.
Next time the function continues from this point.

The advantage of Protothreads over ordinary threads is that a Protothread does not require a separate stack.
In memory constrained systems, the overhead of allocating multiple stacks can consume large amounts of
available memory~\cite{paper-protothreads}.
In contrast each Protothread only requires few bytes for storing the state of execution.

A Protothread is driven by repeated calls to the function in which the Protothread is running.
Each time the function is called, the Protothread will run until it blocks or exits.
Protothreads are implemented using local continuations. A local continuation represents the current state
of execution at a particular place in the program, but does not provide any call history or local variables~\cite{contiki-docs}.

The Protothreads API consists of four basic operations: initialization {\it{PT\_INIT()}}, execution {\it{PT\_BEGIN()}},
conditional blocking {\it{PT\_WAIT\_UNTIL()}} and exit {\it{PT\_END()}}~\cite{paper-protothreads}.
However the experience with rewriting event-driven state machines to Protothreads revealed
the importance of an unconditional blocking wait {\it{PT\_YIELD()}}~\cite{thesis-programming},
which temporarily blocks the Protothread until the next time the Protothread is invoked.
After invocation the Protothread continues executing the code following the {\it{PT\_YIELD()}} statement.
To understand implementation of Protothreads and how do they actually work,
please refer to appendix~\ref{app:protothreads}, where an example of usage is shown.

Since Protothreads are implemented using standard C, library providing Protothreads can be used everywhere C toolchain is available.
But there are some cons to consider. Because Protothreads are stackless, a Protothread can only run within a single C function.
There is also no way of storing automatic local variables~\cite{contiki-docs}.
And since Protothreads are implemented using C {\it switch} statement, and these can
not be nested, the code that uses Protothreads cannot use {\it switch} statements itself.
Workaround for storing local variables is to prepend them with the {\it static} keyword, which make them being put into data segment
by compiler and thus remembering the value between the function calls~\cite{paper-protothreads}.
