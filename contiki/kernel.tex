%=========================================================================
% (c) 2011, 2012 Josef Lusticky <xlusti00@stud.fit.vutbr.cz>

\section{Kernel and processes}
The kernel in Contiki is event-driven providing cooperative multitasking
environment, but the system supports preemptive
multithreading that can be applied on a per-process basis~\cite{video}.
The preemption is not implemented in the kernel, but
preemptive multithreading is implemented as a library that is linked only with programs that
explicitly require multithreading~\cite{paper-contiki}.
The kernel itself contains no platform specific code, it implements only CPU multiplexing and
lets device drivers and applications communicate directly with hardware~\cite{video}.

From high level of abstraction,
applications in Contiki OS are implemented and run as processes.
Protothreads, the lightweight threads described in section~\ref{sec:contiki-protothreads},
are used in Contiki to implement processes.
Both the Contiki kernel and Contiki applications use
Protothreads extensively to achieve cooperative multitasking~\cite{contiki-wiki-faq}.
Every Contiki process consists of a process control block and a process thread~\cite{contiki-wiki-processes}.
The process control block contains run-time information about the process and
the process thread contains the code of the process.
Among other things, the process control block contains
textual name of the process, pointer to the process thread and state of the process.
The process thread is implemented as a single Protothread,
that is invoked from the process scheduler in the Contiki kernel~\cite{contiki-wiki-processes}.

From low level of abstraction,
every application is implemented as a simple C function
and the process control block remembers the actual state of execution of this function
in the same way as the local continuation works by Protothreads.
Processes are therefore running quasi-parallely in Contiki.

\begin{lstlisting}[caption=Process control block in Contiki OS]
struct process {
	struct process *next;
	const char *name;
	int (* thread)(struct pt *, process_event_t, process_data_t);
	struct pt pt;
	unsigned char state, needspoll;
	};
\end{lstlisting}

All code execution is initiated by the Contiki kernel
that acts like a simple dispatcher calling these functions~\cite{contiki-docs}.
Just like Protothreads, processes are also implemented using macros,
making them fully standard C compatible.

%% continue here - UP HERE DONE
In Contiki, code run in either of two execution contexts:
cooperative, in which code never preempts other code, and preemptive,
which preempts the execution of the cooperative code and returns control
when the preemptive code is finished.
Processes always run in cooperative mode, whereas interrupts run in preemptive mode.
The only process control function that can be called from preemptive mode is process\_poll(). 
Processes communicate with each other by posting events to each other.
Events are also posted when a process starts and exits.
%! https://www.sics.se/contiki/wiki/index.php/Processes
In the ... execution context processes cannot be blocked,
instead they run complete~\cite{video, paper-contiki}.

Interprocess communication is done by posting events~\cite{paper-contiki}.
%! todo - process

The Contiki kernel does not provide support for timed events,
instead an application that wants to use timers needs to explicitly use the timer library~\cite{contiki-docs}.
The Contiki timer library is further discussed in section~\ref{sec:contiki-timers}.

%! paper-contiki
In sensor networks, being able to power down the node
when the network is inactive is an often required way to reduce energy consumption.
Power conservation mechanisms
depend on both the applications and the network protocols.
The Contiki kernel contains no explicit power
save abstractions, but lets the the application specific parts
of the system implement such mechanisms.
To help the application decide when to power down the system, the event
scheduler exposes the size of the event queue.
This information can be used to power down the processor when there
are no events scheduled. When the processor wakes up in
response to an interrupt, the poll handlers are run to handle the external event.
%! paper-contiki

As stated before, Contiki is well documented and you can find out more about
the kernel as well as the system in the documentation~\cite{contiki-docs}.
