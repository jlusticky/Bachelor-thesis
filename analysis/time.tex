%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{Time interface}\label{sec:analysis-time}
The clock interrupt is called {\it{clock tick}}, or {\it{timer tick}}, and at each clock tick,
the interrupt service routine increments a system clock value stored in the memory~\cite{thesis-sync}.
In a typical computer clock design, interrupts are produced at
fixed tick intervals in the range 1-20~ms~\cite{nanokernel}.

In Contiki, such a design is on AVR CPUs used by the clock library described in section~\ref{sec:contiki-timers}.
There is a variable counting clock ticks, called {\it{scount}},
and a variable counting seconds, called {\it{seconds}}.
As described in section~\ref{sec:contiki-timers}, there are
exactly {\it{CLOCK\_SECOND}} ticks in one second.
When the {\it{scount}} variable reaches this value,
the {\it{seconds}} variable is incremented and the {\it{scount}} variable is reset.
The {\it{seconds}} variable is used by the Contiki stimers discussed in section~\ref{sec:contiki-timers}.

Since the value of the {\it{seconds}} variable is zero after the system booted,
it actually expresses the system uptime.
The {\it{seconds}} variable can be read by the application using the {\it{clock\_seconds}} call.
However, in Contiki 2.5 there is no call for setting this variable.
In the current Git version at the time of writing, a new call {\it{clock\_set\_seconds}}
can be used for this purpose.
Because this call simply rewrites the {\it{seconds}} variable, it breaks the stimer library,
and should by avoided by the NTP client.
%The {\it{clock_set_seconds}} call is implemented only for three CPU architectures at the time of writing.

The precision of one second is also not adequate for the NTP client.
Further precision can be acquired by reading the {\it{scount}} variable,
as it provides a resolution of $\frac{1}{CLOCK\_SECOND}$~seconds.
Moreover, the hardware counter can be also queried, as it includes the time passed since
the last update of the {\it{scount}} variable.
If stimers should not be broken by setting the {\it{seconds}} variable,
and Contiki should be able to set and provide the current time in a higher precision,
a new call interface must be developed.

Similarly, there is no call for adjusting the time in Contiki.
Due to memory constraints, software structures controlling the time adjustments are too heavyweight
for use in an embedded operating system running on 8-bit CPUs.
Due to lower CPU frequencies, the code of an interrupt service routine can not be complex
and sophisticated clock discipline algorithms should be avoided.
A call for adjusting the time should therefore use abilities
provided by the hardware clock as much as possible.
