%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{Hardware clock interface}
Contiki features a basic clock interface with a simple goal - measuring time.
This interface provides needed calls for timers and its definition is to be found in {\it{/core/sys/clock.h}} file.
Specific implementations of this common interface are located in {\it{/cpu}} directory of Contiki source code.
The interface provides call for initialising CPU's clock system {\it{clock\_init}} that is automatically called during
boot sequence of Contiki.
The goal of the {\it{clock\_init}} call is to set up
appropriate counter registers and interrupt service routines. %! TODO .. as described in chapter..
For AVR CPU this call is implemented as C macro, which evaluates to specific setup code for each
different type of AVR CPU during compilation, and is defined in {\it{cpu/avr/dev/clock-avr.h}} file.
The setup code is not common to all CPUs because of differences among them - e.g. there are usually
only three Timer/Counter modules, but AVR ATmega1284P has four Timer/Counter modules~\cite{avr-datasheet}.

On AVR Raven, 8 bit Timer/Counter~2 clocked from 32~768~Hz watch crystal
is used by Contiki clock interface,
which is in turn used by dependent timers - refer to section~\ref{sec:contiki-timers} for details.
This 32~768~Hz watch crystal is independent of the I/O clock, can be only used
with Timer/Counter~2 and it
enables use of Timer/Counter2 as a Real Time Counter~\ref{avr-datasheet}.

%%Unlike I/O clock used for clocking other Timers/Counters,
%%this asynchronous crystal is also active in power-save mode~\ref{avr-datasheet}.
%CITATION: If Timer/Counter2 is enabled, it will keep running during sleep. The device can wake up from
%either Timer Overflow or Output Compare event from Timer/Counter2.
%If Timer/Counter2 is not running, Power-down mode is recommended instead of Power-save
%mode.
%The Timer/Counter2 can be clocked both synchronously and asynchronously in Power-save
%mode. If the Timer/Counter2 is not using the asynchronous clock, the Timer/Counter Oscillator is
%stopped during sleep. If the Timer/Counter2 is not using the synchronous clock, the clock source
%is stopped during sleep. Note that even if the synchronous clock is running in Power-save, this
%clock is only available for the Timer/Counter2.

Timer/Counter~2 is used in Clear Timer on Compare Match (CTC) mode by Contiki.
In this mode, the counter register {\it{TCNT2}} is cleared to zero when the counter
value matches the value in output compare register {\it{OCR2A}}~\cite{avr-datasheet}.
Additionally, when compare match between counter register and compare register occurs,
interrupt is raised and interrupt service routine {\it{AVR\_OUTPUT\_COMPARE\_INT}},
defined in {\it{cpu/avr/dev/clock.c}} file, is called.
% TO INTERFACE - The OCR2A register defines the top value for the counter, hence also its resolution. %% WHY THEN -1 ?

% The goal of interrupt service routine is to increment ...

For Timer/Counter2 prescale value is 8 in Contiki on AVR Raven platform,
so that 32~768~Hz frequency of clock source is effectively divided by 8.
Counter register is hence incremented with frequency
$f = {\frac{f_{clk}}{prescaler}} = {\frac{32768}{8}} = 4096$ Hz.
%TODO FROM HERE
As described in section~\ref{sec:contiki-timers}, there is
{\it{CLOCK\_SECOND}} macro expressing number of clock interrupts per second.
To obtain {\it{CLOCK\_SECOND}} interrupts per second, the compare register value
must be ${\frac{f}{CLOCK\_SECOND}}$, which is equal to ${\frac{4096}{128}} = 32$
by default for AVR Raven platform in Contiki.
% -1 for CTC

% write to OCR2A
If the interrupt is enabled, the interrupt handler routine can be used for updating
the TOP value. However, changing TOP to a value close to BOTTOM when the counter is run-
ning with none or a low prescaler value must be done with care since the CTC mode does not
have the double buffering feature. If the new value written to OCR2A is lower than the current
value of TCNT2, the counter will miss the compare match.



%clock\_seconds
%CLOCK\_SECOND
This is however enough for implementing a reasonable time interface and using it for NTP client later.

% ntp interface extending the clock library, similar to posix calls


Adjusting time - CLOCK\_COMPARE\_REGISTER = 31 => 128Hz => 1s = 1s
FREQ = 32768/8 / 32
CLOCK\_COMPARE\_REGISTER = 30 => ca132.129Hz => 1s = ca1.032258s
FREQ = 32768/8 / 31
CLOCK\_COMPARE\_REGISTER = 32 => 124.12per => 1s = 0.96p
FREQ = 32768/8 / 33

=> fastest adjust is 0,03s / s


Each TCNT2 increment is $\frac{1}{128 \times 32} \doteq 0,000244$ s
2,44ms minimum clock slew
This is also minimal possible clock adjustment.


Please note, that these adjustments will influence Contiki timers.
Applications requiring uninfluenced timers
are therefore advised to use rtimers, described in section~\ref{sec:contiki-timers},
because they use separate hardware clock unaffected by NTP client
(Timer/Counter~3 on AVR Raven platform).
