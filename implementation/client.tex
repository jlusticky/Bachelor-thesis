%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{Contiki NTP client}
The structure representing an NTP message was borrowed from the OpenNTPD daemon
and the Dragonfly NTP daemon. %!LYDIA
This structure is not using the GCC extension for representing a bit field,
instead uses a single 8-bit integer called {\it{status}}
for Leap Indicator, Version Number and Mode fields of the NTP packet
structure described in section~\ref{sec:ntp-network}.
Accessing each field of the {\it{status}} byte is done using the bitmasks.
Unlike using the bit field extension,
this is compliant with the standard C language~\cite{c99}.

Parameters such as the remote NTP server address, the offset threshold value
or the $\tau$ exponent of NTP poll interval can be configured by a standard C define macro
in the source code or in the Makefile.
The default offset threshold value was chosen 3 seconds,
(approx. 1\% of this amount can be adjusted in 1~second).
The unicast mode can be turned off by specifying no remote host.
In this case, all of the code related to the unicast mode will not be compiled.
The remote NTP server address can be either IPv4 or IPv6 address,
but can not be specified by a domain name.
The client is written IP-version agnostic and the {\it{UIP\_CONF\_IPV6}} macro is only used
to print the remote server address when debugging.

% STATE MACHINE
The NTP client is written as an event-driven process,
that yields when there is no event to be served.
This behaviour is comparable to the daemon mode in other operating systems.

%% packet loss
Upon sending the packet, the NTP client process sets the event timer,
yields and waits for the next event by the {\it{PROCESS\_WAIT\_EVENT}} statement.
Therefore, no active waiting blocks the whole system.

The NTP process is later invoked either in response to the incoming packet event
or in response to the timer expiration event.
If any other running application wants the NTP client to query the server,
it can send the {\it{PROCESS\_EVENT\_MSG}} event to the NTP process at any time.
However, no event is sent to that application when the server response arrives.
Applications can instead experience a change of
the system time by the {\it{clock\_get\_time}} call.
Listing~\ref{lst:implementation-client} shows the Contiki NTP client pseudocode.
\begin{lstlisting}[caption={NTP client pseudocode},label={lst:implementation-client}]
PROCESS_THREAD(event)
{
  for(;;) {  // main loop
    PROCESS_WAIT_EVENT();
    if(event == tcpip_event) {
      tcpip_handler();
    }
#ifdef REMOTE_HOST  // unicast mode support
    else if(etimer_expired()) {
      timeout_handler();
      etimer_restart();  // set etimer to 2^TAU seconds
    } else if(event == PROCESS_EVENT_MSG)  // event from another application
    {
      timeout_handler();
    }
#endif
  }
}

tcpip_handler(void)  // process incoming server packet
{
  clock_get_time();
  offset = compute_offset();
  if(abs(offset) >= ADJUST_THRESHOLD) {
    clock_set_time();
  } else {
    clock_adjust_time();
  }
}

#ifdef REMOTE_HOST
timeout_handler(void)  // send query to REMOTE_HOST
{
  clock_get_time();
  fill_and_send_ntp_packet();
}
#endif REMOTE_HOST
\end{lstlisting}


Dynamic increasing or decreasing the client's Poll interval in response to
Kiss-o'-Death packets, described in section~\ref{sec:ntp-network}, is not implemented.
The implementation instead assumes, that an exhausted NTP server rather drops the incoming
client's packet than sending the response with a KoD code.


%%%
The conversion discussed in~\ref{sec:design-client}
%This conversion uses only shifts and additions
%and the resulting binary is 
\begin{lstlisting}[caption=Conversion from NTP fraction part to nanoseconds]
unsigned long fractionl_to_nsec(uint32_t fractionl)
{
  unsigned long nsec;
  nsec = fractionl;
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = nsec/2 + nsec/8 = (5*nsec)/8
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = (5*nsec) / 8 = (25*fractionl)/64
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = fractionl * 5^3/2^9
  /* Now we can multiply by 5^2 because then the total
   * multiplication coefficient for the original number fractionl
   * will be: fractionl * (5^5)/((2^3)^4) = fractionl * 0.762939453,
   * which is less then 1, so it can not overflow.
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  nsec = (nsec >> 1) + (nsec >> 3);
  nsec = (nsec >> 1) + (nsec >> 3);

  /* Again we can multiply by 5^2.
   * Total coefficient will be fractionl * (5^9)/((2^3)^7) = fractionl * 0.931322575
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  /* Last shift to agree with division by 2^23 can not be
   * done earlier since the coefficient would always be greater than 1.
   */
  nsec = nsec >> 2;
  return nsec;
}
\end{lstlisting}
%%TODO
As the code comments say, an extra attention must be taken of the overall
multiplication coefficient,
that can not be greater than 1 in any step.

According to output from the {\it{avr-size}} tool,
when compiled with GCC 4.3.5,
using the 64-bit arithmetic for conversion
takes 656 bytes more in %program section of
resulted binary file (GCC supplies routine for multiplication and shifting 64-bit integers)
and floating point operation takes 3~358 bytes more
than the developed algorithm.


Besides significantly smaller memory requirements,
this algorithm provides on AVR Raven even more accurate results than the libgcc
floating point library supplied by GCC.


%NEW
Because the current NTP Era ends in 2036,
the NTP client application code has to be changed in the future~\cite{ntp-y2k}.
The client uses no IP version specific code,
therefore a communication over IPv4 should be also possible.
This was not tested though, due to a missing simple solution for
IPv4 communication over IEEE~802.15.4 link layer.
