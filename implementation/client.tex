%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{NTP client code}
The client itself is implemented as a Contiki process.
Parameters such as remote port, local port or poll interval
can be configured using standard C define macro.
The client can communicate using both,
the NTP broadcast mode and the NTP unicast mode.
The unicast mode can be turned off by specifying no remote host.

Structure representing NTP message was borrowed from OpenNTPD NTP Unix daemon
and Dragonfly NTP daemon.
This structure is not using the GCC extension for representing a bit field,
instead uses a single 8-bit integer called {\it{status}}
for Leap Indicator, Version Number and Mode fields of NTP packet
described in section~\ref{sec:ntp-network}.
Accessing each field of the {\it{status}} byte is done using bitmasks.
Unlike using the bit field extension,
such design is compliant with the standard C language.

A client sends messages to each server with a poll interval of $2^{\tau}$
seconds, as determined by the poll exponent $\tau$ (tau).
In NTPv4, $\tau$ ranges from 4 (16 s) to 17 (36 h).



The clock are set if the time difference is equal or greater than
treshold value. (3s)
The reference NTP implementation uses 125 ms~\cite{rfc5905}.

It has been the Internet
experience that the need to change the system time in increments
greater than +-128 ms is extremely rare and is usually associated
with a hardware or software malfunction or system reboot~\cite{rfc1589}.
\begin{lstlisting}
if (labs((signed long) (ts.sec - tmpts.sec)) > 2)
{
  clock_set_time(ts.sec);
}
\end{lstlisting}
Even if {\it{tmpts.sec}} value is greater than {\it{ts.sec}} value,
subtracting and casting to signed type gives correct (negative) result~\cite{c99}.
Assuming 32-bit data types this will work until 2038 when wrap around can occur due to difference
between {\it{ts.sec}} and {\it{tmpts.sec}} greater than $2^{31}$-1 (2~147~483~647).
But as NTP Era 0 ends 2036 the NTP client code must be changed in the future anyway.

%! TODO

%Adjusting time
%1/128/32 = 0.000244141
%0.000244141x32x127+0.000244141x31 == smallest possible adjustment == 244us

%% SENDING NTP TIMESTAMP
The transmit timestamp sent by the client can be set to any arbitrary value.
This is in compliance with the NTPv4 specification~\cite{rfc5905}.
It is, however, important for the client to store the sent timestamp,
since it is later used by the client to check the server's response.
Contiki NTP Client fills and checks only the seconds part of NTP timestamp,
because the timestamp should be as accurate as possible and the
conversion from nanoseconds to NTP fraction part would increase the interval
between determination of the timestamp and dispatch of the packet.

After the filled NTP packet is sent, the client schedules
sending of a next NTP packet in $2^{\tau}$ seconds
using the event timer library.
Upon scheduling the timer, the client process yields
and another process can be run.
The client process is later invoked either by the uIP stack event
announcing the server response
or by the event timer in case no server response arrived.

When the server response arrives,
determinating the destination timestamp is one of the first thing the client does.
After that, the client makes packet sanity tests including
checking whether the response is from synchronised server.

Next follows determination of the NTP communication mode.
In unicast mode, the seconds field of Originate timestamp
is compared with the stored sent timestamp.
The received packet is considered bogus in case of mismatch and further processing is stopped.
Otherwise are the NTP timestamps converted to local timestamp format and
the local clock offset computed as described in section~\ref{sec:ntp-algorithms}.
After the local clock offset is computed,
the stored transmitted timestamp is set to zero
to protect against replay of the last transmitted packet,
and the time is set or adjusted using the {\it{clock\_set\_time}}
or {\it{clock\_adjust\_time}} call. %respectively

In broadcast mode, the received packet is always considered correct
and the local clock offset is computed as the difference between the local stored timestamp
and the transmit timestamp received.
As one could expect, the local clock offset determined from the broadcast mode
is less accurate then from the unicast mode.
The broadcast mode is intended particularly for energy constrained clients
or for a huge number of NTP clients and a single NTP server
in a network with small propagation delay.

The conversion from NTP fraction part and nanoseconds is made using...
%%TODO from here...

%\section{NTP values and convertions}
Unlike the RFC 5905~\cite{rfc5905} shows, there are no 64 bit values. %! RFC - A.4. Kernel System Clock Interface
No floating point numbers - library.
Division of unsigned integer number by 2 is automatically translated by compiler to logical right shift,
making it fast operation.

Converting between NTP and local timestamps requires floating point operations or 64-bit numbers.
According to output from avr-size tool, using 64-int number for conversion
uses 4~330 bytes more in %program section of
resulted binary file
and floating point operation takes 3~474 bytes more
than algorithm developed.
uint64\_t with shift 728 bytes more.

C99 - shift E1 >> E2: if E1 has a signed type and a nonnegative value, the value of
the result is the integral part of the quotient of $E1 / 2^{E2}$.

This algorithm has even higher precision than floating point library
supplied by GCC.
In case of floating point operations, the libgcc is used.
\url{http://gcc.gnu.org/onlinedocs/gccint/Libgcc.html}

%
% NEGATIVE result for the first time
In some scenarios where the initial frequency offset of the client is
  relatively large and the actual propagation time small, it is
   possible for the delay computation to become negative.  For instance,
   if the frequency difference is 100 ppm and the interval T4-T1 is 64
   s, the apparent delay is -6.4 ms.  Since negative values are
   misleading in subsequent computations, the value of delta should be
   clamped not less than s.rho, where s.rho is the system precision
   described in Section 11.1, expressed in seconds~\cite{rfc5905}.
%
