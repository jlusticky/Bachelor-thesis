%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{NTP client code}
The client itself is implemented as a Contiki process.
Parameters such as remote port, local port or poll interval
can be configured using standard C define macro.
The client can communicate using both,
the NTP broadcast mode and the NTP unicast mode.
The unicast mode can be turned off by specifying no remote host.

Structure representing NTP message was borrowed from OpenNTPD daemon
and Dragonfly NTP daemon.
This structure is not using the GCC extension for representing a bit field,
instead uses a single 8-bit integer called {\it{status}}
for Leap Indicator, Version Number and Mode fields of NTP packet
described in section~\ref{sec:ntp-network}.
Accessing each field of the {\it{status}} byte is done using bitmasks.
Unlike using the bit field extension,
such design is compliant with the standard C language.


%Even if {\it{tmpts.sec}} value is greater than {\it{ts.sec}} value,
%subtracting and casting to signed type gives correct (negative) result~\cite{c99}.
%Assuming 32-bit data types this will work until 2038 when wrap around can occur due to difference
%between {\it{ts.sec}} and {\it{tmpts.sec}} greater than $2^{31}$-1 (2~147~483~647).
%But as NTP Era 0 ends 2036 the NTP client code must be changed in the future anyway~\cite{ntp-y2k}.

%! TODO

%Adjusting time
%1/128/32 = 0.000244141
%0.000244141x32x127+0.000244141x31 == smallest possible adjustment == 244us

%% SENDING NTP TIMESTAMP
The transmit timestamp sent by the client can be set to any arbitrary value.
This is in compliance with the NTPv4 specification~\cite{rfc5905}.
It is however important for the client to store the sent timestamp,
since it is later used by the client to check the server's response.
Contiki NTP Client fills and checks only the seconds part of NTP timestamp,
because the timestamp should be as accurate as possible and the
conversion from nanoseconds to NTP fraction part would increase the interval
between determination of the timestamp and dispatch of the packet.

After the filled NTP packet is sent, the client schedules
sending of a next NTP packet in $2^{\tau}$ seconds
using the event timer library.
In NTPv4, $\tau$ ranges from 4, resulting in poll interval 16 seconds,
to 17, resulting in poll interval 36 hours.
However, the event timer library imposes a limit to scheduled time.
This limit is platform specific and depends on {\it{CLOCK\_SECOND}} value.
The $\tau$ value can not be greater than 8 on AVR Raven assuming 128 interrupts per second.
Upon scheduling the event timer, the client process yields
and another process can be run.
The client process is later invoked either by the uIP stack event
announcing the server response
or by the event timer in case no server response arrived.
Event timer is therefore effectively
dealing with possible packet loss described in section~\ref{sec:design-network}.

When the server response arrives,
determinating the destination timestamp is one of the first thing the client does.
After that, the client makes packet sanity tests including
checking whether the response is from synchronised server.

A determination of the NTP communication mode follows.
In unicast mode, the seconds field of Originate timestamp
is compared with the stored sent timestamp.
The received packet is considered bogus in case of mismatch and further processing is stopped.
Otherwise are the NTP timestamps converted to local timestamp format and
the local clock offset computed as described in section~\ref{sec:ntp-algorithms}.
After the local clock offset is computed,
the stored transmitted timestamp is immediately set to zero
to protect against replay of the last transmitted packet.

In broadcast mode, the received packet is always considered correct
and the local clock offset is computed as the difference between the local stored timestamp
and the transmit timestamp received.
As one could expect, the local clock offset determined from the broadcast mode
is less accurate then from the unicast mode.

Due to a different origin of the Unix and NTP epoch,
number of seconds between NTP and Unix epoch,
is subtracted from seconds part of NTP timestamp.
But the conversion from fraction part of long 64-bit NTP timestamp to nanoseconds,
used in the local timestamp structure,
is one of the most problematic tasks for memory constrained systems.
An accurate conversion requires either floating point operations or operations with 64 bit numbers.
The conversion is given by
$nsec = fractionl \times 10^9 \div 2^{32}$, where $nsec$ is the nanoseconds part of the local timestamp
and $fractionl$ is the fraction part of long 64-bit NTP timestamp.
Since there is no native hardware support for floating point nor for 64-bit arithmetic,
GCC would supply these operations in form of library called {\it{libgcc}},
which causes significantly bigger resulted binary file.
The greatest common divisor of $10^9$ and $2^{32}$ is $2^9$,
so in fact, a relatively simple multiplication of $fractionl$ by $\frac{5^9}{2^{23}}$ must be computed.
This can be computed using sequential divisions and multiplications,
which in turn can be done on 32 bits using shifts and additions~\cite{c99}.
\begin{lstlisting}[caption=Conversion from NTP fraction part to nanoseconds]
unsigned long
fractionl_to_nsec(uint32_t fractionl)
{
  unsigned long nsec;
  nsec = fractionl;
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = nsec/2 + nsec/8 = (5*nsec)/8
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = (5*nsec) / 8 = (25*fractionl)/64
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = fractionl * 5^3/2^9
  /* Now we can multiply by 5^2 because then the total
   * multiplication coefficient for the original number fractionl
   * will be: fractionl * (1/(2^3)^4)*5^5 = fractionl * 0.762939453,
   * which is less then 1, so it can not overflow.
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  nsec = (nsec >> 1) + (nsec >> 3);
  nsec = (nsec >> 1) + (nsec >> 3);

  /* Again we can multiply by 5^2.
   * Total coefficient will be fractionl * (1/(2^3)^7)*5^9 = fractionl * 0.931322575
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  /* Last shift to agree with division by 2^23 can not be
   * done earlier since coefficient would always be greater than 1.
   */
  nsec = nsec >> 2;
  return nsec;
}
\end{lstlisting}
As the code comments say, an extra attention must be taken of the overall coefficient,
which can not be greater than 1 in any step.
Because $fractionl$ can be of any value between $0$ and $2^{32}-1$,
the overall coefficient greater than 1 could cause overflow and an unexpected result.

According to output from the {\it{avr-size}} tool,
when compiled with GCC 4.3.5,
using the 64-bit arithmetic for conversion
takes 656 bytes more in %program section of
resulted binary file (GCC supplies routine for multiplication and shifting 64-bit integers)
and floating point operation takes 3~358 bytes more
than the developed algorithm.

It must be noted, that the above presented conversion is not exactly accurate, particularly
because of loosing the least significant bits by the first shifts.
However, this conversion gives maximum error of 5 nanoseconds for all possible values of $fractionl$,
which is totally adequate for most platforms without floating point unit or
for platforms where usage of 64-bit arithmetic is expansive.
Beside significantly smaller memory requirements,
this algorithm gives on AVR Raven even more accurate results than the libgcc
floating point library supplied by GCC.


In the next step after conversions, the local clock offset is computed
as given in section~\ref{sec:ntp-algorithms}.
Depending on the absolute value of the local clock offset,
the system time is either set or adjusted using the {\it{clock\_set\_time}}
and {\it{clock\_adjust\_time}} call respectively.
The clock is set if the time difference is equal or greater than
treshold value, which 3 seconds by default. %!TODO
The reference NTP implementation uses 125 ms~\cite{rfc5905}
It has been the Internet
experience that the need to change the system time in increments
greater than +-128 ms is extremely rare and is usually associated
with a hardware or software malfunction or system reboot~\cite{rfc1589}.


%
% NEGATIVE result for the first time
%In some scenarios where the initial frequency offset of the client is
  %relatively large and the actual propagation time small, it is
   %possible for the delay computation to become negative.  For instance,
   %if the frequency difference is 100 ppm and the interval T4-T1 is 64
   %s, the apparent delay is -6.4 ms.  Since negative values are
   %misleading in subsequent computations, the value of delta should be
   %clamped not less than s.rho, where s.rho is the system precision
   %described in Section 11.1, expressed in seconds~\cite{rfc5905}.
%
