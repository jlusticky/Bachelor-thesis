%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{Contiki NTP client}
The structure representing an NTP message was borrowed from the OpenNTPD daemon
and the Dragonfly NTP daemon. %!LYDIA
This structure is not using the GCC extension for representing a bit field,
instead uses a single 8-bit integer called {\it{status}}
for Leap Indicator, Version Number and Mode fields of the NTP packet
structure described in section~\ref{sec:ntp-network}.
Accessing each field of the {\it{status}} byte is done using the bitmasks.
Unlike using the bit field extension,
this is compliant with the standard C language~\cite{c99}.

Parameters such as the remote NTP server address, the offset threshold value
or the $\tau$ exponent of NTP poll interval can be configured by a standard C define macro
in the source code or in the Makefile.
The default offset threshold value was chosen 3 seconds,
(approx. 1\% of this amount can be adjusted in 1~second).
The unicast mode can be turned off by specifying no remote host.
In this case, all of the code related to the unicast mode will not be compiled.

The client is IP-version agnostic and the {\it{UIP\_CONF\_IPV6}} macro is only used
to print the remote server address when debugging.
The remote NTP server address can be either IPv4 or IPv6 address,
but can not be specified by a domain name.
Communication over IPv4 was not tested though, due to a missing simple solution for
IPv4 communication over IEEE~802.15.4 link layer. %!LYDIA

% DONE
The NTP client is written as an event-driven process, that never exits.
Upon sending the NTP query, the NTP client process sets the event timer,
yields and waits for the next event by using the {\it{PROCESS\_WAIT\_EVENT}} statement.
This is comparable to the daemon mode in other operating systems.

The NTP process is later invoked either in response to the incoming packet event
or in response to the timer expiration event.
This way, no active waiting blocks the whole system.
If any other running application wants the NTP client to query the server,
it can send the {\it{PROCESS\_EVENT\_MSG}} event to the NTP process at any time.
However, no event is sent to that application when the server response arrives.
Applications can instead experience a change of
the system time by the {\it{clock\_get\_time}} call.
Listing~\ref{lst:implementation-client} shows the Contiki NTP client pseudocode.
\begin{lstlisting}[caption={NTP client pseudocode},label={lst:implementation-client}]
PROCESS_THREAD(event)
{
  for(;;) {  // main loop
    PROCESS_WAIT_EVENT();
    if(event == tcpip_event) {
      tcpip_handler();
    }
#ifdef REMOTE_HOST  // unicast mode support
    else if(etimer_expired()) {
      timeout_handler();
      etimer_restart();  // set etimer to 2^TAU seconds
    } else if(event == PROCESS_EVENT_MSG)  // event from another application
    {
      timeout_handler();
    }
#endif
  }
}

tcpip_handler(void)  // process incoming server packet
{
  clock_get_time();
  offset = compute_offset();
  if(abs(offset) >= ADJUST_THRESHOLD) {
    clock_set_time();
  } else {
    clock_adjust_time();
  }
}

#ifdef REMOTE_HOST
timeout_handler(void)  // send query to REMOTE_HOST
{
  clock_get_time();
  fill_and_send_ntp_packet();
}
#endif REMOTE_HOST
\end{lstlisting}


Dynamic increasing or decreasing the client's Poll interval in response to
Kiss-o'-Death packets, described in section~\ref{sec:ntp-network}, is not implemented.
The implementation instead assumes, that an exhausted NTP server rather drops the incoming
client's packet than sending the response with a KoD code.


Listing~\ref{} shows the conversion from the NTP timestamp to the POSIX timestamp,
as discussed in~\ref{sec:design-client}.
The conversion uses only shifts and additions, which makes the resulting binary file
significantly smaller.
Because the current NTP Era ends in 2036,
the conversion of seconds has to be changed in the future~\cite{ntp-y2k}.
\begin{lstlisting}[caption={Conversion from NTP timestamp to POSIX timestamp},label={lst:implementation-conversion}]
#define	JAN_1970  2208988800UL    /* 1970 - 1900 in seconds */

void ntp_to_ts(const struct l_fixedpt *ntp, struct time_spec *ts)
{
  ts->sec = ntp->int_partl - JAN_1970;
  ts->nsec = fractionl_to_nsec(ntp->fractionl);
}

unsigned long fractionl_to_nsec(uint32_t fractionl)
{
  unsigned long nsec;
  nsec = fractionl;
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = nsec/2 + nsec/8 = (5*nsec)/8
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = (5*nsec) / 8 = (25*fractionl)/64
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = fractionl * 5^3/2^9
  /* Now we can multiply by 5^2 because then the total
   * multiplication coefficient of the original number fractionl
   * will be: fractionl * (5^5)/((2^3)^4) = fractionl * 0.762939453,
   * which is less then 1, so it can not overflow.
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  nsec = (nsec >> 1) + (nsec >> 3);
  nsec = (nsec >> 1) + (nsec >> 3);

  /* Again we can multiply by 5^2.
   * Total coefficient will be fractionl * (5^9)/((2^3)^7) = fractionl * 0.931322575
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  /* Last shift to agree with division by 2^23 can not be
   * done earlier since the coefficient would always be greater than 1.
   */
  nsec = nsec >> 2;
  return nsec;
}
\end{lstlisting}
According to the output from the {\it{avr-size}} tool,
the use of 64-bit arithmetic operations for the conversion
takes 728 bytes more in the
resulted binary file (GCC supplies routines for multiplication and shifting 64-bit integers)
and floating point operations take 3~358 bytes more
than the developed algorithm.
Besides significantly smaller memory requirements,
this algorithm provides on AVR Raven more accurate results than the libgcc
floating point library supplied by GCC.
