%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{NTP client application code}
The structure representing an NTP message was borrowed from OpenNTPD daemon
and Dragonfly NTP daemon.
This structure is not using the GCC extension for representing a bit field,
instead uses a single 8-bit integer called {\it{status}}
for Leap Indicator, Version Number and Mode fields of NTP packet
described in section~\ref{sec:ntp-network}.
Accessing each field of the {\it{status}} byte is done using bitmasks.
Unlike using the bit field extension,
such a design is compliant with the standard C language.

% STATE MACHINE
The NTP client is written as an event-driven state machine process,
that yields when there is no event to be served.
This behaviour is comparable to the daemon mode in other operating systems.

%CONFIGURATION
Parameters such as remote port, local port or the $\tau$ exponent of Poll interval
can be configured using a standard C define macro.
The unicast mode can be turned off by specifying no remote host.
In this case, all of the code related to the unicast mode will not be compiled.


When the server response arrives,
the destination timestamp determination is one of the first action the client does.
After that, the client makes packet sanity tests including
checking whether the response is from synchronised server.

A determination of the NTP communication mode follows.
In unicast mode, the seconds field of Originate timestamp
is compared with the stored sent timestamp.
The received packet is considered bogus in case of mismatch and further processing is stopped.
Otherwise, the NTP timestamps are converted to the local timestamp format and
the local clock offset is computed as described in section~\ref{sec:ntp-algorithms}.
After the local clock offset is computed,
the stored transmitted timestamp is immediately set to zero
to protect against replay of the last transmitted packet.

In broadcast mode, the received packet is always considered correct
and the local clock offset is computed as the difference between the local stored timestamp
and the transmit timestamp received.
As one could expect, the local clock offset determined from the broadcast mode
is less accurate then from the unicast mode.




%%%
\begin{lstlisting}[caption=Conversion from NTP fraction part to nanoseconds]
unsigned long
fractionl_to_nsec(uint32_t fractionl)
{
  unsigned long nsec;
  nsec = fractionl;
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = nsec/2 + nsec/8 = (5*nsec)/8
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = (5*nsec) / 8 = (25*fractionl)/64
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = fractionl * 5^3/2^9
  /* Now we can multiply by 5^2 because then the total
   * multiplication coefficient for the original number fractionl
   * will be: fractionl * (5^5)/((2^3)^4) = fractionl * 0.762939453,
   * which is less then 1, so it can not overflow.
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  nsec = (nsec >> 1) + (nsec >> 3);
  nsec = (nsec >> 1) + (nsec >> 3);

  /* Again we can multiply by 5^2.
   * Total coefficient will be fractionl * (5^9)/((2^3)^7) = fractionl * 0.931322575
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  /* Last shift to agree with division by 2^23 can not be
   * done earlier since the coefficient would always be greater than 1.
   */
  nsec = nsec >> 2;
  return nsec;
}
\end{lstlisting}
As the code comments say, an extra attention must be taken of the overall
multiplication coefficient,
that can not be greater than 1 in any step.
Because $fractionl$ can be of any value between $0$ and $2^{32}-1$,
the overall coefficient greater than 1 could cause overflow and an unexpected result.

According to output from the {\it{avr-size}} tool,
when compiled with GCC 4.3.5,
using the 64-bit arithmetic for conversion
takes 656 bytes more in %program section of
resulted binary file (GCC supplies routine for multiplication and shifting 64-bit integers)
and floating point operation takes 3~358 bytes more
than the developed algorithm.

It must be noted, that the above presented conversion is not exactly accurate, particularly
because of loosing the least significant bits by the first shifts.
However, this conversion gives maximum error of 5 nanoseconds for all possible values of $fractionl$,
which is totally adequate for most platforms without floating point unit or
for platforms where usage of 64-bit arithmetic is expansive.
Besides significantly smaller memory requirements,
this algorithm provides on AVR Raven even more accurate results than the libgcc
floating point library supplied by GCC.


In the next step after conversions, the local clock offset is computed
as given in section~\ref{sec:ntp-algorithms}.
Depending on the absolute value of the local clock offset,
the system time is either set or adjusted using the {\it{clock\_set\_time}}
and {\it{clock\_adjust\_time}} call respectively.
The clock is set if the time difference is equal or greater than
treshold value, which 3 seconds by default. %!TODO
The reference NTP implementation uses 125 ms~\cite{rfc5905}
It has been the Internet
experience that the need to change the system time in increments
greater than +-128 ms is extremely rare and is usually associated
with a hardware or software malfunction or system reboot~\cite{rfc1589}.
