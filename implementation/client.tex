%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{Contiki NTP client}
The structure representing an NTP message was borrowed from OpenNTPD daemon
and Dragonfly NTP daemon.
This structure is not using the GCC extension for representing a bit field,
instead uses a single 8-bit integer called {\it{status}}
for Leap Indicator, Version Number and Mode fields of the NTP packet
structure described in section~\ref{sec:ntp-network}.
Accessing each field of the {\it{status}} byte is done using the bitmasks.
Unlike using the bit field extension,
such a design is compliant with the standard C language.

% STATE MACHINE
The NTP client is written as an event-driven state machine process,
that yields when there is no event to be served.
This behaviour is comparable to the daemon mode in other operating systems.

%% packet loss
Upon sending the packet, the NTP client process sets the event timer and yields
using the {\it{PROCESS\_YIELD}} statement,
so no active waiting causes blocking the whole system.
The NTP process is then invoked either in response to the incoming NTP packet event
or in response to the timer expiration event.
If any other running application wants the NTP client to query the server,
it can send the {\it{PROCESS\_EVENT\_MSG}} event to the NTP process at any time.
However, no event is sent to that application when the server response arrives.

%CONFIGURATION
Parameters such as the remote port, the local port
or the $\tau$ exponent of NTP poll interval can be configured using a standard C define macro
in the source code as well as in the Makefile.
The unicast mode can be turned off by specifying no remote host.
In this case, all of the code related to the unicast mode will not be compiled.

The remote NTP server can be specified in the Makefile or
by using the {\it{REMOTE\_HOST}} define macro.
If no remote host is specified, the NTP client assumes that only the NTP broadcast communication mode will be used.
The link layer MAC address and the NTP poll exponent $\tau$
can be configured in the Makefile as well.


%%%
\begin{lstlisting}[caption=Conversion from NTP fraction part to nanoseconds]
unsigned long
fractionl_to_nsec(uint32_t fractionl)
{
  unsigned long nsec;
  nsec = fractionl;
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = nsec/2 + nsec/8 = (5*nsec)/8
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = (5*nsec) / 8 = (25*fractionl)/64
  nsec = (nsec >> 1) + (nsec >> 3); // nsec = fractionl * 5^3/2^9
  /* Now we can multiply by 5^2 because then the total
   * multiplication coefficient for the original number fractionl
   * will be: fractionl * (5^5)/((2^3)^4) = fractionl * 0.762939453,
   * which is less then 1, so it can not overflow.
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  nsec = (nsec >> 1) + (nsec >> 3);
  nsec = (nsec >> 1) + (nsec >> 3);

  /* Again we can multiply by 5^2.
   * Total coefficient will be fractionl * (5^9)/((2^3)^7) = fractionl * 0.931322575
   */
  nsec = (nsec << 1) + nsec + (nsec >> 3); // nsec*3 + nsec/8 = (25*nsec) / 8

  /* Last shift to agree with division by 2^23 can not be
   * done earlier since the coefficient would always be greater than 1.
   */
  nsec = nsec >> 2;
  return nsec;
}
\end{lstlisting}
As the code comments say, an extra attention must be taken of the overall
multiplication coefficient,
that can not be greater than 1 in any step.
Because $fractionl$ can be of any value between $0$ and $2^{32}-1$,
the overall coefficient greater than 1 could cause overflow and an unexpected result.

According to output from the {\it{avr-size}} tool,
when compiled with GCC 4.3.5,
using the 64-bit arithmetic for conversion
takes 656 bytes more in %program section of
resulted binary file (GCC supplies routine for multiplication and shifting 64-bit integers)
and floating point operation takes 3~358 bytes more
than the developed algorithm.

It must be noted, that the above presented conversion is not exactly accurate, particularly
because of loosing the least significant bits by the first shifts.
However, this conversion gives maximum error of 5 nanoseconds for all possible values of $fractionl$,
which is totally adequate for most platforms without floating point unit or
for platforms where usage of 64-bit arithmetic is expansive.
Besides significantly smaller memory requirements,
this algorithm provides on AVR Raven even more accurate results than the libgcc
floating point library supplied by GCC.

The client and the developed interface uses no IP version specific code,
therefore a communication over IPv4 should be also possible.
This was due to a missing simple solution for
communicating over IPv4 on IEEE~802.15.4 link layer not tested though.
