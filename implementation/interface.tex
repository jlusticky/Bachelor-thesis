%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{Operating system clock interface}
%Since there is no way of setting, getting and adjusting the time in Contiki OS,
%the interface for setting, getting and adjusting time was developed in this thesis.

The structure similar to POSIX {\it{timespec}} structure (described in section~\ref{sec:others-posix})
was implemented for expressing time values.
However name was chosen {\it{time\_spec}} to avoid collision with existing POSIX-compliant systems.
\begin{lstlisting}
struct time_spec {
  long sec;
  long nsec;
};
\end{lstlisting}
The structure representing time specification uses signed long values.
The value 0 seconds and 0 nanoseconds is equal to Unix prime epoch (1st January 1970).
In case of seconds part, the 32-bit signed long value was chosen because
it can conveniently
represent real-time values as well as local clock adjustment values, which may also be negative.
%! The existing value {\it{seconds}}, representing uptime in Contiki, is of the unsigned long type.
Such time representation will wrap around in year 2038 and is facing
what is commonly known as the year 2038 problem~\cite{posix}.

In case of nanoseconds part, the 32-bit signed long value was chosen because
one second has 1~000~000~000 nanoseconds and it is
desirable to be able to express positive as well as negative values for local clock adjustments.
As 32-bit signed long type shall be able to express values from -$2^{31}$-1 (-2~147~483~647)
to $2^{31}$-1 (2~147~483~647)~\cite{c99},
such representation will therefore never wrap around.
The nanosecond precision was chosen as modern systems also aim towards this
precision~\cite{posix,ntp-precision} and
the microsecond precision would also require at least 32-bit data type -
one second has 1~000~000 microseconds, which is more than maximum expressible value of unsigned 16-bit
data type $2^{16}$-1 (65~535).

It should be noted that signed long data type does not have to always result in 32-bit variable -
it is up to compiler what data width it chooses for each data type.
But as ISO C99 standard states, the maximum value for an object of type signed long
shall be greater or equal $2^{31}$-1 (2~147~483~647)~\cite{c99}.
This in fact results in at least 32-bit variable unless the compilation setting is changed.
Next to this, as the already presented variable {\it{seconds}} is of unsigned long type,
the value {\it{sec}} in {\it{time\_spec}} structure %and {\it{boottime}}
shall be of the same data width as arithmetic operations are made on them.

Usage of unsigned data type prolongs the wrap around to year 2106,
however will disable use of negative values needed for adjusting local clock.
%As current NTP Era ends 2036~\cite{rfc5905} code has to be changed anyway...

Setting the current real-time is only possible within one second precision -
finer time setting must be made through time adjustments described further.
Implemented {\it{clock\_set\_time}} function computes when the system started
in seconds since the Epoch and saves the result in newly implemented {\it{boottime}} variable.

Not only no variables incremented every interrupt nor any internal clock registers
are affected, but also already presented variable {\it{seconds}} is not modified.
This variable, counting uptime in seconds,
is particularly used by Contiki timers.
It is therefore desired to not modify it, as this would lead to misbehaviour of timer modules
described in section~\ref{sec:contiki-timers}.

Thanks to this newly implemented function and variable,
running Contiki system is then able to tell uptime, current real-time and
when the system was booted.
\begin{lstlisting}
volatile unsigned long boottime;

void
clock_set_time(unsigned long sec)
{
  boottime = sec - seconds;
}
\end{lstlisting}

Getting the correct real-time is only possible if set using
the {\it{clock\_set\_time}} function before.
Implemented function called {\it{clock\_get\_time}} is able to tell the
current time in seconds since the Epoch by simply adding {\it{boottime}},
and {\it{seconds}}.
%! TODO
Nanoseconds part is filled using {\it{scount}} variable counting number of
interrupts within a second.
Since this variable is incremented every interrupt and there are {\it{CLOCK\_SECOND}} interrupts
per second, it is possible to get resolution of $\frac{1~000~000~000}{CLOCK\_SECOND}$ ns.
The same resolution have Contiki timers, described in section~\ref{sec:contiki-timers}.
\begin{lstlisting}
void
clock_get_time(struct time_spec *ts)
{
  ts->sec = boottime + seconds;
  ts->nsec = (1000000000 / CLOCK_SECOND) * scount;
}
\end{lstlisting}
Because {\it{1000000000}} and {\it{CLOCK\_SECOND}} are both constants, compiler is able to
calculate the result of division during compile time.
Furthermore as both numbers are integers, the result is integer as well~\cite{c99}.
The most of CPU time is therefore spent on multiplication.
E.g. if the code is compiled using GCC version 4.3.5,
multiplication of two 32-bit variables takes 33 instructions including {\it{call}} and {\it{ret}}
instructions for entering and returning from the {\it{\_\_mulsi3}} routine, which computes
the result of multiplication.
%avr-objdump
According to AVR Instruction Set manual~\cite{avr-instruction-set},
this results in 48 clock cycles overhead,
which takes 3~000 nanoseconds assuming 16MHz CPU clock.
The timestamp provided is therefore not exact.
However, since this consumed time strongly depends on architecture and compiler specifications,
no correction was implemented to remove this inaccuracy.
The application must be instead aware that the timestamp is not exactly accurate.

TODO: Greater precision is further implemented by reading counter register.

TODO: Adjust time
POSIX:
Time values that are between two consecutive non-negative integer multiples
of the resolution of the specified clock are truncated down to the smaller multiple of the resolution.
