%=========================================================================
% (c) 2011, 2012 Josef Lusticky <xlusti00@stud.fit.vutbr.cz>

%\chapter{CD Content}
%\begin{tabular}{|l|l|}
	%\hline
	%Directory & Content \\ \hline
	%bib/ & Bibliography used in citations \\
	%\hline
%\end{tabular}

\chapter{Protothreads example}\label{app:protothreads}
Here is
%Next page shows
an example of delaying text on an LCD panel using Protothreads.
It is taken from
Adam Dunkels' Protothreads website~\cite{adam-protothreads} and slightly modified.
Protothreads can be used for introducing delays inside a function, without using a full threading model.
The example shows a function writing characters to LCD panel.
Suppose each character is shown for one second, then next character replaces previous.
\begin{lstlisting}[numbers=left]
#include "pt.h"
#include "timer.h"
#include <string.h>

typedef unsigned short lc_t;

struct pt {
  lc_t lc;                                           /* Local continuation */
}; 

struct pt state;
struct timer timer;
 
PT_THREAD(display_text(struct pt *pt, const char *msg))
{
  PT_BEGIN(pt);
  for (int i = 0; i < strlen(msg); i++) {
    lcd_display_char(msg[i]);
    timer_set(&timer, CLOCK_SECOND);               /* Wait for one second. */
    PT_WAIT_UNTIL(pt, timer_expired(&timer));
  }
  PT_END(pt);
}

int main(void)
{
  PT_INIT(&state);
  for (;;) {
    display_text(&state, "Hello world");
    /* Here can be another thread run */
  }
  return 0;
}
\end{lstlisting}
%\newpage
The PT\_WAIT\_UNTIL macro actually causes the function to return.
While the function is waiting for the timer to expire another function can be called and run.
When the function is entered again the execution continues with the PT\_WAIT\_UNTIL macro
which causes the function to check the condition it is waiting for (timer expired).
If the condition is met the function resumes, if not it returns again.
Strictly speaking the amount of time between showing each character can
be more than one second.
This is because Protothreads are not running simultaneously: when the timer expires
and another Protothread is running, this Protothread would have to wait until
it is entered again. Than the condition specified in PT\_WAIT\_UNTIL is met and
next iteration of loop started, that is, next character is displayed.

How does it work? The macro PT\_BEGIN is expanded to {\it switch} statement while preprocessing the
code for compilation.
The PT\_WAIT\_UNTIL macro expands to {\it case} and setting the local continuation
to the value, so that next time this function is run, it jumps to this {\it case}.
The structure holding the state is defined outside of the function so its context is not lost when
the function returns. The simplest state structure would hold just the local continuation variable.

Now follows
%Next page shows
the same sample of code after simplified preprocessing.
%\newpage
\begin{lstlisting}[numbers=left]
#include "pt.h"
#include "timer.h"
#include <string.h>

typedef unsigned short lc_t;

struct pt {
  lc_t lc;                                           /* Local continuation */
}; 

struct pt state;
struct timer timer;

int display_text(struct pt *pt, const char *msg)     /* Expanded PT_THREAD */
{
  switch(pt->lc) {  case 0:                      /* Expanded PT_BEGIN(pt); */
  
    for (int i = 0; i < strlen(msg); i++) {
      lcd_display_char(msg[i]);
      timer_set(&timer, CLOCK_SECOND);             /* Wait for one second. */
    
                                   /* The following two lines are expanded */
      pt->lc = 31; case 31:   /* PT_WAIT_UNTIL(pt, timer_expired(&timer)); */
      if(!(timer_expired(&timer))) { return PT_WAITING; }         /* macro */
    
    }
  
  pt->lc = 0; return PT_ENDED; }                        /* Expanded PT_END */
  
}

int main(void)
{
  state->lc = 0;                                       /* Expanded PT_INIT */
  for (;;) {
    display_text(&state, "Hello world");
    /* Here can be another thread run */
  }
  return 0;
}

\end{lstlisting}

\chapter{Interesting dates for NTP}\label{app:dates}
NTP timestamps are unsigned values, and operations on them produce a
result in the same or adjacent Eras.
Era 0 includes dates from the prime epoch to some time in 2036,
when the timestamp field wraps around and the base date for Era 1 is established.
In either format, a value of zero is a special case representing unknown or
unsynchronized time~\cite{rfc5905}.

This table shows a number of interesting NTP dates
together with their corresponding NTP Era and NTP timestamp.
The table is taken from RFC 5905~\cite{rfc5905}.

\vspace{1cm}

\begin{tabular}{|l|l|l|l|}
	\hline
	Date & NTP Era & NTP Timestamp & Epoch \\ \hline
	1 Jan -4712 & -49 & 1 795 583 104 & First day Julian \\
	1 Jan 0 & -14 & 171 311 744 & 1 BCE \\
	1 Jan 1 & -14 & 202 939 144 & 1 CE \\
	31 Dec 1899 & -1 & 4 294 880 896 & Last day NTP Era -1 \\
	1 Jan 1900 & 0 & 0 & First day NTP \\
	1 Jan 1970 & 0 & 2 208 988 800 & First day UNIX \\
	31 Dec 1999 & 0 & 3 155 587 200 & Last day 20th Century \\
	8 Feb 2036 & 1 & 63 104 & First day NTP Era 1 \\
	\hline
\end{tabular}

\chapter{Requirements for NTP client and Contiki 2.5 support}\label{app:requirements}
\begin{tabular}{|l|l|}
	\hline
	Requirement & Contiki support \\ \hline
	Communication using UDP & Complete \\
	DNS resolution & Missing IPv6, otherwise complete \\
	Setting the clock & Complete \\
	Adjusting the clock & None \\
	Setting the time & None \\
	Getting the time & None \\
	% Tomas Kasparek: semaphores, locks, ... ?
	\hline
\end{tabular}
