%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\chapter{Analysis}
For keeping, measuring and resolving the time, computer needs a hardware clock.
A computer clock is an electronic device with a counter register counting oscillations in a
quartz crystal oscillator with a particular frequency~\cite{thesis-sync}.
Using the hardware clock, the operating system can keep and manipulate the system time.

Accessing the hardware clock is done through the operating system clock interface.
On top of the clock interface is an interface for providing the system time.
For implementation of a reasonably useful NTP client,
the operating system must be able to set, get and eventually adjust the system time
through the time interface.
Though not mandatory, adjusting the time is an important function,
if the time shall be always a monotonically increasing function.

Apart from that, an ability to communicate over UDP is also required for the NTP client.
This is a task of the operating system network interface.
Figure~\ref{fig:analysis-overview} shows the overview of NTP client components.

\begin{figure}
  \centering
  \includegraphics[width=13cm,keepaspectratio]{fig/analysis.png}
  \caption{NTP client overview} %!TODO
  \label{fig:analysis-overview} %!TODO
\end{figure}

For developing and testing Contiki NTP Client,
the AVR Raven platform with 8-bit ATmega1284P CPU~\cite{avr-datasheet} will be used.
This platform features IEEE~802.15.4 (Low-Rate Wireless Personal Area Networks) link layer support.
Together with an adaptation layer called 6LoWPAN (IPv6 over Low power Wireless Personal Area Networks),
AVR Raven is able to communicate over IPv6.

\input{analysis/hwclock.tex}

\input{analysis/clock-interface.tex}

\input{analysis/time.tex}


\section{NTP client application}
Apart from the time interface, the NTP client application needs to use the operating system network interface.
Thanks to uIP, the network communication is not a matter for Contiki OS.

The NTP client needs server associations in the NTP unicast communication mode.
However, too many server associations complicate the client design.
In fact, in the most common scenario, there can be only a single NTP master server
for the whole network.
A single server association requires just a simple calculation of the local clock offset
$\theta$, whereas more server associations require the intersection algorithm
described in section~\ref{sec:ntp-algorithms}.
Implementation of such an algorithm, requiring advanced data structures, should be avoided
in a memory constrained system.

The NTP broadcast communication mode, on the other hand,
requires no associations and no packet filling process on the client side.
Moreover, because the client does not have to actively send any NTP packets,
an energy consumption of the client is reduced.

% 1 - see design
A problem might be a possible packet loss when communication uses UDP on transport layer.
The reason why this can happen often in Contiki, is explained in section~\ref{sec:contiki-uip}.
% 2
In NTP unicast mode, the packet loss might occur either for a client's query to the server
or for a server's response to the client.
If the client's query loss occurs, no server response will be sent.
Similarly, if the server's response loss occurs, no message will be received by the client.
Not to block a whole system till the response arrives
is therefore a desired behaviour of the client.

The NTP client should be able to communicate over both IPv4 and IPv6.
Thanks to the uIP stack, this is no a matter for Contiki.
The only constraint is that both IP versions can not be used simultaneously
and the decision must be made during the compilation~\cite{contiki-docs}.
Although the {\it{UIP\_CONF\_IPV6}} macro can be used to determine which IP version
support is being compiled, the NTP client application can be written IP-version agnostic.

The NTP client further calculates the local clock offset using the NTP timestamps
as described in section~\ref{sec:ntp-algorithms}.
As mentioned in section~\ref{sec:ntp-time}, the NTP timescale is not
coincident with the POSIX timescale.
If the new calls in the time interface should use the standard POSIX timescale,
conversion between NTP and POSIX timestamps must be calculated.
The conversion from the POSIX timestamp to the 64-bit long NTP timestamp
is needed when the client sends the request
and the conversion vice versa is needed when the client calculates
the local clock offset from the received timestamps.

Since both timescales reckon in seconds, the conversion between
the NTP timestamp seconds field value and the POSIX timestamp seconds field value is simple.
However, the conversion between the NTP fraction field value ($2^{-32}$)
and the POSIX fraction field value (nanoseconds or microseconds) is problematic.
The relation between the POSIX fraction field and the NTP fraction field
is given by $POSIX.frac = NTP.frac \times POSIX.res \div 2^{32}$,
where $POSIX.frac$ is the POSIX fraction field value,
$NTP.frac$ is the NTP fraction field value and
$POSIX.res$ is the POSIX timestamp resolution (microseconds or nanoseconds).
The accurate conversion requires either floating point operations or operations with 64 bit numbers.
These operations can be memory expensive, especially on 8-bit microcontrollers,
and their usage must be considered carefully or another suitable solution must be found.
