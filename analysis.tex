%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\chapter{Analysis}
For implementation of a reasonably useful NTP client,
an operating system must be able to set, get and eventually adjust the system time.
Though not mandatory, adjusting the time is an important function,
if the time shall be always a monotonically increasing function.
Apart from that, ability to communicate over UDP is also required.

For developing and testing Contiki NTP Client,
the AVR Raven platform with 8-bit ATmega1284P CPU~\cite{avr-datasheet} will be used.
This platform features IEEE~802.15.4 (Low-Rate Wireless Personal Area Networks) link layer support.
Together with an adaptation layer called 6LoWPAN (IPv6 over Low power Wireless Personal Area Networks),
AVR Raven is able to communicate over IPv6.

\input{analysis/time.tex}

\input{analysis/clock.tex}


\section{Communication}
Without any NTP server is an NTP client useless. % There are clients, servers...
However, too many server associations complicate the client design.
In fact, in the most common scenario, there can be only a single NTP master server
for the whole network.
A single server association requires just a simple calculation of the local clock offset
$\theta$, whereas more server associations require the intersection algorithm
described in section~\ref{sec:ntp-algorithms}.
Implementation of such an algorithm, requiring advanced data structures, should be avoided
in a memory constrained system.

The NTP broadcast communication mode, on the other hand,
requires no associations and no packet filling process on the client side.
Moreover, because the client does not have to actively send any NTP packets,
an energy consumption of the client is reduced.

% 1 - see design
A problem might be a possible packet loss when communication uses UDP on transport layer.
The reason why this can happen often in Contiki, is explained in section~\ref{sec:contiki-uip}.
% 2
In NTP unicast mode, the packet loss might occur either for a client's query to the server
or for a server's response to the client.
If the client's query loss occurs, no server response will be sent.
Similarly, if the server's response loss occurs, no message will be received by the client.
Not to block a whole system till the response arrives
is therefore a desired behaviour of the client.

The NTP client should be able to communicate over both IPv4 and IPv6.
Thanks to the uIP stack, this is no a matter for Contiki.
The only constraint is that both IP versions can not be used simultaneously
and the decision must be made during the compilation~\cite{contiki-docs}.
Although the {\it{UIP\_CONF\_IPV6}} macro can be used to determine which IP version
support is being compiled, the NTP client application can be written IP-version agnostic.


\section{Timestamp conversions}%CLIENT CODE
As mentioned in section~\ref{sec:ntp-time}, the NTP timescale is not
coincident with the POSIX timescale.
If the new call interface should use the standard POSIX timescale,
conversion between NTP and POSIX timestamps must be calculated.
The conversion from the POSIX timestamp to the 64-bit long NTP timestamp
is needed when the client sends the request
and the conversion vice versa is needed when the client calculates
the local clock offset from the received timestamps.

Since both timescales reckon in seconds, the conversion between
the NTP timestamp seconds field value and the POSIX timestamp seconds field value is simple.
However, the conversion between the NTP fraction field value ($2^{-32}$)
and the POSIX fraction field value (nanoseconds or microseconds) is problematic.
The relation between the POSIX fraction field and the NTP fraction field
is given by $POSIX.frac = NTP.frac \times POSIX.res \div 2^{32}$,
where $POSIX.frac$ is the POSIX fraction field value,
$NTP.frac$ is the NTP fraction field value and
$POSIX.res$ is the POSIX timestamp resolution (microseconds or nanoseconds).
The accurate conversion requires either floating point operations or operations with 64 bit numbers.
These operations can be memory expensive, especially on 8-bit microcontrollers,
and their usage must be considered carefully or another suitable solution must be found.
