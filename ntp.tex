%=========================================================================
% (c) 2011, 2012 Josef Lusticky <xlusti00@stud.fit.vutbr.cz>

\chapter{Network Time Protocol}
Network Time Protocol provides mechanism for synchronising systems' clocks over the variable-latency data network.
NTP was introduced and is still developed by David Mills at University of Delaware in Newark, United States~\cite{ntp-history}.
NTP is argueably the longest running, continuously operating,
ubiquitously available protocol in the Internet~\cite{ntp-overview}.
Despite being one of the oldest surviving protocol on the Internet, it is not old-fashioned at all.
NTP version 4 described in RFC~5905~\cite{rfc5905} is an update to older NTPv3 to accomodate NTP to IPv6.
Version 4 also includes improvements in
the mitigation and discipline algorithms that extend
the potential accuracy to the tens of microseconds with modern
workstations and fast LANs~\cite{rfc5905}.
NTPv4 corrects some
errors in NTPv3 design and includes optional extension mechanism
that can be used for adding more capabilites to NTP, e.g. the
Autokey security protocol described in RFC~5906
for authenticating servers to clients.

Simple Network Time Protocol is simplified NTP implementation lacking complex
synchronisation algorithms used by NTP~\cite{rfc5905}.
SNTP is also described in RFC 5905.
The packet of SNTP has the same structure and content as packet of NTP~\cite{rfc5905}.
From observing the network communication one can not tell whether the client
is full blown NTP implementation or just SNTP.
SNTP is a simplified sub-set of the algorithms used by the NTP protocol
making the client implementation not only easier, but also suitable for
resource constraint systems such as embedded systems.
Since NTP and SNTP servers and clients are
completely interoperable and can be intermixed in NTP subnets~\cite{rfc5905},
this thesis refers to SNTP client for Contiki OS as NTP client.


\input{ntp/topology.tex}

\input{ntp/time.tex}

\input{ntp/network.tex}

\input{ntp/algorithms.tex}

%! review
\section{Hardware concerns for implementing real-time support}
A typical desktop computer today includes CPU based on Intel x86 architecture.
Real-Time Clock (RTC) in CMOS memory that is battery powered

Unfortunately Intel x86 architecture is heavily influenced by backwards compatibility,
e.g. the time value can also be stored in Binary Code Digit (BCD) encoding in RTC.

In year 19xx / Starting with Intel 386
Intel introduced
Programmable Interrupt Controller (PIT) Intel 8253 and 8254 - 3 counters (counter 0 interrupt to OS)


Used by historic versions of Linux
=> read initial time from RTC, setup PIT and interrupts (IRQ 0, INT 8), increment jiffies on every interrupt, provide app resolution of jiffies

init/main.c - time\_init() - read from RTC and save to startup\_time
kernel/sched.c - sched\_init() = PTI setup for interrupts - LATCH (1193180/HZ)
kernel/system\_call.s - timer\_interrupt() in assembly - increments jiffies

The current real time is provided by CURRENT\_TIME (startup\_time+jiffies/HZ) => since jiffies is integer and HZ is 100 => resolution of 10ms.
kernel/sys.c - sys\_time() - CURRENT\_TIME returned


\section{NTP on POSIX-compliant systems}
Operating systems
Linux
OpenBSD
DragonflyBSD

NTP implementations
NTP from ntp.org project - reference implementation
Chrony
OpenNTPD - OpenBSD
dntpd - DragonflyBSD

