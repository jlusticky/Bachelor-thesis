%=========================================================================
% (c) 2011, 2012 Josef Lusticky

\section{POSIX-compliant systems}\label{sec:others-posix}
NTP daemon is an application running in user-space using kernel calls to set, get and
adjust system time.

The operating system is assumed to provide two
functions: one to set the time directly, for example, the Unix
settimeofday() function, and another to adjust the time in small
increments advancing or retarding the time by a designated amount,
for example, the Unix adjtime() function~\cite{rfc5905}.

The operating system interface is specified by POSIX standard on Unix-like operating systems~\cite{posix}.

Traditionally, {\it{gettimeofday}} call can be used get current time on Unix systems.
Setting the time can be done using {\it{settimeofday}} call.
Both calls manipulate with microsecond precision and
are widely supported among current Unix-like operating systems.
POSIX 2001 describes {\it{gettimeofday}} but not {\it{settimeofday}}.
POSIX 2008 marks {\it{gettimeofday}} as obsolete, recommending instead the use
of {\it{clock\_gettime}}, which is capable of nanosecond precision.
Next to this, {\it{clock\_settime}} for setting the time and {\it{clock\_getres}}
for getting clock resolution are specified in POSIX 2008 standard~\cite{posix}.
This standard further specifies that
the system header file {\it{time.h}} shall declare {\it{timespec}} structure
capable of expressing nanosecond precision.
\begin{lstlisting}[morekeywords={clockid_t,time_t}]
clock_gettime(clockid_t clock_id, struct timespec *res);
clock_settime(clockid_t clock_id, const struct timespec *res);
clock_getres(clockid_t clock_id, struct timespec *res);

struct timespec {
  time_t  tv_sec;
  long    tv_nsec;
}
\end{lstlisting}
All implementations shall support a clock\_id of {\it{CLOCK\_REALTIME}} as
defined in header file {\it{time.h}}.
This clock represents the clock measuring real time for the system.
For this clock, the values returned by {\it{clock\_gettime}} and specified
by {\it{clock\_settime}} represent the amount
of time in seconds and nanoseconds since the Epoch.


Operating systems:

Linux
OpenBSD - Kernel calls gettimeofday, settimeofday, adjtime, no kernel discipline (timex structure)
as of OpenBSD 5.1 ntp\_gettime and ntp\_adjtime not implemented
DragonflyBSD - Kernel calls int ntp\_adjtime(struct timex *tp),
BUT ONLY IN KERNEL: int ntp\_gettime(struct ntptimeval *ntv) - nanosecond resolution -> timex.h

NTP implementations:

NTP from ntp.org project - reference implementation
Uses array for converting between Unix and NTP timestamp.
This approach does not fit for use with memory constrained systems.

Chrony

OpenNTPD - OpenBSD - secure, less robust, easy to configure - for converting between NTP and local timestamps uses double
data type and floating point arithmetic operations including division (util.c)
	/*
	 * Send out a random 64-bit number as our transmit time.  The NTP
	 * server will copy said number into the originate field on the
	 * response that it sends us.  This is totally legal per the SNTP spec.
	 *
	 * The impact of this is two fold: we no longer send out the current
	 * system time for the world to see (which may aid an attacker), and
	 * it gives us a (not very secure) way of knowing that we're not
	 * getting spoofed by an attacker that can't capture our traffic
	 * but can spoof packets from the NTP server we're communicating with.
	 *
	 * Save the real transmit timestamp locally.
	 */

dntpd - DragonflyBSD
only sends seconds
%wmsg.xmttime.int_partl = time(NULL) + JAN_1970;
%wmsg.xmttime.fractionl = random();
For converting between NTP and local timestamps uses division and modulo in convert.c.


clockspeed
